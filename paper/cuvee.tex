\documentclass[fleqn]{llncs}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}

% nice code font
\usepackage[scaled=0.8]{beramono}

% math stuff
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{mathtools}
\usepackage{proof}

\usepackage{xspace}

% grammars
\usepackage{syntax}
\setlength{\grammarindent}{8em}

% nice citations
\usepackage[numbers]{natbib}

% clickable links and cross-references
\usepackage{hyperref}
\hypersetup{hidelinks,
    colorlinks=true,
    allcolors=blue,
    pdfstartview=Fit,
    breaklinks=true}

% easy cross-references with \cref
\usepackage[capitalise,nameinlink]{cleveref}

\pagestyle{plain}

\newcommand{\Cuvee}{\textsc{Cuv√©e}\xspace}
\newcommand{\code}[1]{\texttt{#1}}
\newcommand{\hoare}[3]{\{ #1 \}~#2~\{ #3 \}}
\newcommand{\hoaretotal}[3]{[ #1 ]~#2~[ #3 ]}

\newcommand{\xs}{\underline x}
\newcommand{\ys}{\underline y}

\newcommand{\nonterminal}[1]{\ensuremath{\langle \mathit{#1} \rangle}}

\title{\Cuvee: Blending SMT-LIB with \\ Programs and Weakest Preconditions}
\author{Gidon Ernst}
\institute{LMU Munich, Germany, \email{gidon.ernst@lmu.de}}


\begin{document}
\maketitle

\begin{abstract}
\Cuvee is a program verification tool that reads SMT-LIB-like input files where terms may additionally contain weakest precondition operators over abstract programs.
\Cuvee translates such inputs into first-order SMT-LIB by symbolically executing these programs.
The input format used by \Cuvee is intended to bring different verification communities closer together and achieve a similar unification of tools for that for example synthesize loop summaries.
A notable technical aspect of \Cuvee itself is the consequent use of loop pre-/postconditions instead of invariants, and we demonstrate how this lowers the annotation burden on some simple while programs.
Moreover, \Cuvee can express refinement conditions between multiple programs.
\end{abstract}

\begin{keywords}
Program Verification, SMT-LIB, Weakest Precondition
\end{keywords}

\section{Introduction}

Intermediate verification languages and tools such as Boogie, Why3, and Viper
have had a significant impact on the state-of-the-art of (deductive) program verification.
At the annual competition on interactive program verification VerifyThis~\cite{},
tools like these are put to practice on small but intricate verification problems.

SMT-LIB~\cite{} is a standardized interchange format for verification tasks in first-order logic
that is widely used in many different application domains such as constraint-solving, program verification, and model-checking.
Many mature tools are available \cite{}, and the annual SMT-COMP evaluates and compares their performance on benchmark problems.
Part of the success of the SMT-LIB format is its regular syntax and its precise standardization.

SV-COMP~\cite{} is 


In comparison to existing intermediate verification languages such as Boogie, Why3, and Viper,
it is more light-weight and aims to be easier to implement and process automatically.
The input format used by \Cuvee is intended to bridge the gap between automated theorem proving,
and between the goals of SV-COMP (fully automatic verification of C programs)
and the VerifyThis competition (

\section{Input Language}
\label{sec:language}

This section highlights the syntactic additions to SMT-LIB and includes a brief description of the intended meaning,
given via predicate transformer semantics.

\subsection{Syntax}
\label{sec:syntax}

The new constructs accepted by \Cuvee are shown in \cref{fig:syntax}.

\begin{figure}[t]
    \begin{grammar}
    <var_binding>
        ::= "(" <symbol> <term> ")"

    <term>
        ::=  "(wp" <program> <term>")"
        \alt "(box" <program> <term>")"
        \alt "(dia" <program> <term>")"
        \alt "(old" <term> ")"
        \alt ...

    <program>
        ::=  "(assign" "("<var_binding>")"$^+$ ")"
        \alt "(spec"   "(" <symbol>$^+$ ")" <term> <term> ")"
        \alt "(block"  <program>$^+$ ")"
        \alt "(if"     <term> <term> <term> ")"
        \alt "(while"  <term> <term> <attribute>$^+$ ")"

    <command>
        ::=  "(assert-counterexample" <term> <program> <term> ")"
        \alt ...
    \end{grammar}
    \caption{Extension of the SMT-LIB supported by \Cuvee:
             Weakest-precondition operators,
             simple nondeterministic \textsc{While} programs,
             and a top-level command to specify Hoare triples
             (\nonterminal{var\_binding} is from the SMT-LIB grammar).}
    \label{fig:syntax}
\end{figure}

Terms \nonterminal{term} of SMT-LIB are extended by three weakest-precondition operators,
\code{(wp  $p$ $t$)}, \code{(box $p$ $t$)}, \code{(dia $p$ $t$)}
for programs~$p$ (see below)
and postconditions~$t$ (terms of sort \code{Bool},
which state slightly different correctness criteria with respect to termination and nondeterministic choices.

The first one, \code{wp} denotes Dijkstra's well-known weakest precondition:
All executions of~$p$, when started in the current state, terminate and lead to a state that satisfies~$t$.
For instance, a Hoare triple for total correctness $\hoaretotal{\phi}{p}{\psi}$ can be written as the implication \code{(=> $\phi$ (wp $p$ $\psi$))}

Similarly, \code{box} does not require termination (i.e., it expresses the weakest liberal precondition),
i.e., $\hoare{\phi}{p}{\psi}$ can be written as \code{(=> $\phi$ (box $p$ $\psi$))}.

The operator \code{dia} reflects angelic execution instead of demonic execution:
For \code{(dia $p$ $t$)} it is required that there is at least one execution of~$p$
that terminates and leads to a state that satisfies~$t$.
The names of the latter two operators is taken from Dynamic Logic~\cite{}.

The expression \code{(old $t$)} is intended for use in loop annotations.
It refers to previous states of the execution at the beginning of loop iterations.

\medskip

Programs \nonterminal{program} provide familiar constructs from a simple sequential \textsc{While} language.

Parallel assignments evaluate all right-hand-sides simultaneously,
e.g. \code{(assign (x y)  (y x))} swaps the values stored in the variables \code{x} and \code{y}.
Note that there is no syntactic difference between program variables and logical ones,
and the former ones may range over arbitrary SMT-LIB data types.

Specification statements \code{(spec ($x_1 \cdots x_n$) $\phi \psi$)}
encode arbitrary, possibly nondeeterministic transitions~\cite{}.
The effect of executing such a statement is that the precondition~$\phi$ of the statement
is asserted (i.e., needs to hold in the current state),
then the variables \code{$x_1 \cdots x_n$} are given fresh arbitrary values,
and the postcondition $\psi$ is assumed for the remainder of the execution.

Specification statements can encode assertions (\code{assert $\phi$} becomes \code{(spec () $\phi$ true)}),
assumptions (\code{assume $\psi$} becomes \code{(spec () true $\psi$)}),
and the statement \code{havoc $x_1 \cdots x_n$} from e.g. Boogie~\cite{}
(which becomes \code{(spec ($x_1 \cdots x_n$) true true)}).

Within the postcondition of a specification statement, \code{old} refers to the pre-state of the statement itself.
This admits elegant encoding of transition relations,
i.e., \code{(spec (x) true (> x (old x)))} specifies that the new value of \code{x} is strictly larger than the previous one.

Specification statements are useful internally, too, to encode the inductive hypothesis of the loop rule implemented in \Cuvee (see \cref{sec:syntax}).

Sequential composition is written as \code{(block $p_1 \cdots p_n$)}, where \code{(block)} denotes the empty statement.
Conditional statements \code{(if $b$ $p_1$ $p_2$)} execute either~$p_1$ or~$p_2$ depending of the evaluation of the test~$b$ (a boolean term) in the current state.

\medskip
\noindent
While loops
\[ \code{(while $b$ $p$ :termination $t$ :precondition $\phi$ :postcondition $\psi$)} \]
execute $p$ as long as the test~$b$ holds true.
\Cuvee supports some attributes that can be used to specify loop annotations,
namely, a termination measure~$t$, a loop precondition~$\phi$, and a loop postcondition~$\psi$.
All three annotations are optional.

\medskip

A new top-level command \code{(assert-counterexample $\phi$ $p$ $\psi$)}
asserts that the Hoare triple $\hoaretotal{\phi}{p}{\psi}$ is not valid.
This command roughly translates to \code{(assert (not (=> $\phi$ (wp $p$ $\psi$))))},
however, \Cuvee implements special cases when $p$ is a while loop without a pre-/postcondition annotation
to derive the loop specification from such a contract.
Moreover, within a \code{assert-counterexample} command,
\code{old} in the postcondition $\psi$ refers to the pre-state.
Note that this feature is currently not expressible in the expression/program language alone,
but can be emulated if needed by introducing additional logical variables capturing this pre-state explicitly.

Consistent with the standard pattern in SMT-LIB, where formulas are proved by searching for satisfying assignments of the negation,
an \code{unsat} from the underlying SMT solver on the problem translated by \Cuvee indicates that there is no counterexample
i.e., the program is correct with respect to the specified contract.

\subsection{Proof Rules}
\label{sec:semantics}

\begin{figure}[t]
    \begin{align*}
\code{(wp (assign (($x_1$ $t_1$) $\cdots$ ($x_n$ $t_n$))) $Q$)}
    & \equiv Q[x_1,\ldots,x_n \gets t_1,\ldots,t_n]
    \\
\code{(wp (block $p_1 \cdots p_n$ $Q$)}
    & \equiv \code{(wp $p_1$ $\cdots$ (wp $p_n$ $Q$))}
    \\
\code{(wp (if $b$ $p_1$ $p_2$) $Q$)}
    & \equiv        \code{(and (=> $b$ (wp $p_1$ $Q$))} \\
    & \hspace{30pt} \code{     (=> (not $b$) (wp $p_2$ $Q$)))}
    \end{align*}

    \begin{gather*}
\infer{\code{(wp (spec ($\xs$) $\phi$ $\psi$) $Q$)}}
{   \phi
 && \code{(forall ($\ys$) $\psi[\underline{\code{(old $x$)}} \gets \xs, \xs \gets \ys]
                            \to Q[\xs \gets \ys]$)}
              }
    \\[1em]
\infer{\code{(box (while $b$ $p$) $Q$)}}
{   
\begin{array}{c}
   \code{(box (spec ($\xs$) $\phi$ $\psi$) $Q$)} \\
   \code{(forall ($\xs$) (=> (and $\phi$ (not $b$)) $Q[\underline{\code{(old $x$)}} \gets \xs]$))} \\
   \code{(forall ($\xs$) (=> (and $\phi$ $b$) (box (block $p$ (spec ($\xs$) $\phi$ $\psi$)) $\psi$)$[\underline{\code{(old $x$)}} \gets \xs]$))}
\end{array}}
    \\
        \qquad \text{where $\phi$ is the precondition of the loop and $\psi$ is the postcondition,} \\
        \qquad \text{$\xs$ are the variables modified by the loop body~$p$ and $\ys$ are fresh.}
    \end{gather*}
    \label{fig:semantics}
    \caption{Predicate transformer semantics for the programming language in \cref{fig:syntax}.
             The rules for the specification statement and loops are given as inference rules
             to improve readability (these could be equally formulated as equivalences).}
\end{figure}

The predicate transformer semantics of the input language is shown in \cref{fig:semantics} for the \code{wp} operator,
with the exception of the loop rule, which is shortened to omit the termination conditions
and therefore expressed using \code{box}. The rules for \code{box} and \code{dia} are similar.
Note that~$Q$ is a term that may again contain weakest-precondition operators.

The first three equivalences are standard~\cite{}.
Assignments propagate as a simultaneous substitution into the postcondition~$Q$.
Sequential execution simply nests the weakest precondition operator.
Conditionals produce two branches that evaluate the test positively resp.~negatively.

The specification statement binds fresh copies~$\ys$ for the havoc'ed variables~$\xs$,
and substitutes \code{old} expressions in the postcondition~$\psi$.
The first premise simply asserts the precondition~$\phi$.

\medskip

The loop rule is more involved and proceeds by induction on the number of loop iterations.
It has three premises:
The first, abstracts the entire execution of the loop loop with a specification statement,
after which the postcondition~$Q$ needs to hold.

The second premise corresponds to the base case of the induction
and establishes $Q$ upon termination (when $b$ is false).
Old values in~$Q$ refer to the current state.

The third premise corresponds to the inductive case, where~$b$ holds.
Then, the condition to show is that after executing the loop body~$p$ once,
the inductive hypothesis about the remaining iterations is sufficient to establish~$\psi$ after the entire loop.
This hypothesis is encoded as a specification statement
\code{(spec ($\xs$) $\phi$ $\psi$)}
that abstracts the remaining iterations, similarly as in the first premise.

The interaction between the different occurrences of \code{old} is somewhat intricate:
Within the specification statement, \code{old} refers to the state \emph{after} the first iteration,
according to the corresponding proof rule.
Hence, the it encodes that it is possible at that point to turn the precondition~$\phi$
into an arbitrary state after the remaining iterations that satisfies~$\psi$ for fresh copies of the modified variables~$\xs$
introduced by the specification statement.
Ultimately, this knowledge needs to suffice to establish~$\psi$ after the loop with \emph{all} iterations,
where \code{old} refers to the state \emph{before} executing the first iteration~$p$.

A good explanation of this loop rule can be found e.g. in~\cite{}.

\section{Tool Description}
\label{sec:tool}

\section{Examples}

\end{document}

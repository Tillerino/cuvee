\documentclass[fleqn]{llncs}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}

% nice code font
\usepackage[scaled=0.8]{beramono}

% math stuff
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{mathtools}

\usepackage{xspace}

% grammars
\usepackage{syntax}
\setlength{\grammarindent}{8em}

% nice citations
\usepackage[numbers]{natbib}

% clickable links and cross-references
\usepackage{hyperref}
\hypersetup{hidelinks,
    colorlinks=true,
    allcolors=blue,
    pdfstartview=Fit,
    breaklinks=true}

% easy cross-references with \cref
\usepackage[capitalise,nameinlink]{cleveref}

\pagestyle{plain}

\newcommand{\Cuvee}{\textsc{Cuv√©e}\xspace}
\newcommand{\code}[1]{\texttt{#1}}
\newcommand{\hoare}[3]{\{ #1 \}~#2~\{ #3 \}}
\newcommand{\hoaretotal}[3]{[ #1 ]~#2~[ #3 ]}

\newcommand{\nonterminal}[1]{\ensuremath{\langle \mathit{#1} \rangle}}

\title{\Cuvee: Blending SMT-LIB with \\ Programs and Weakest Preconditions}
\author{Gidon Ernst}
\institute{LMU Munich, Germany, \email{gidon.ernst@lmu.de}}


\begin{document}
\maketitle

\begin{abstract}
\Cuvee is a program verification tool that reads SMT-LIB-like input files where terms may additionally contain weakest precondition operators over abstract programs.
\Cuvee translates such inputs into first-order SMT-LIB by symbolically executing these programs.
The input format used by \Cuvee is intended to bring different verification communities closer together and achieve a similar unification of tools for that for example synthesize loop summaries.
A notable technical aspect of \Cuvee itself is the consequent use of loop pre-/postconditions instead of invariants, and we demonstrate how this lowers the annotation burden on some simple while programs.
Moreover, \Cuvee can express refinement conditions between multiple programs.
\end{abstract}

\begin{keywords}
Program Verification, SMT-LIB, Weakest Precondition
\end{keywords}

\section{Introduction}

Intermediate verification languages and tools such as Boogie, Why3, and Viper
have had a significant impact on the state-of-the-art of (deductive) program verification.
At the annual competition on interactive program verification VerifyThis~\cite{},
tools like these are put to practice on small but intricate verification problems.

SMT-LIB~\cite{} is a standardized interchange format for verification tasks in first-order logic
that is widely used in many different application domains such as constraint-solving, program verification, and model-checking.
Many mature tools are available \cite{}, and the annual SMT-COMP evaluates and compares their performance on benchmark problems.
Part of the success of the SMT-LIB format is its regular syntax and its precise standardization.

SV-COMP~\cite{} is 


In comparison to existing intermediate verification languages such as Boogie, Why3, and Viper,
it is more light-weight and aims to be easier to implement and process automatically.
The input format used by \Cuvee is intended to bridge the gap between automated theorem proving,
and between the goals of SV-COMP (fully automatic verification of C programs)
and the VerifyThis competition (

\section{Input Format}

\begin{figure}
    \begin{grammar}
    <var_binding>
        ::= "(" <symbol> <term> ")"

    <term>
        ::=  "(wp" <program> <term>")"
        \alt "(box" <program> <term>")"
        \alt "(dia" <program> <term>")"
        \alt ...

    <program>
        ::=  "(assign" "("<var_binding>")"$^+$ ")"
        \alt "(spec"   "(" <symbol>$^+$ ")" <term> <term> ")"
        \alt "(if"     <term> <term> <term> ")"
        \alt "(while"  <term> <term> <term> ")"

    <command>
        ::=  "(assert-counterexample" <term> <program> <term> ")"
        \alt ...
    \end{grammar}
    \caption{Extension of the SMT-LIB supported by \Cuvee:
             Weakest-precondition operators,
             simple nondeterministic \textsc{While} programs,
             and a top-level command to specify Hoare triples
             (\nonterminal{var\_binding} is from the SMT-LIB grammar).}
    \label{fig:syntax}
\end{figure}

The additional constructs accepted by \Cuvee are shown in \cref{fig:syntax}.

\Cuvee extends the \nonterminal{term} language of SMT-LIB by three weakest-precondition operators,
\code{(wp  $p$ $t$)}, \code{(box $p$ $t$)}, \code{(dia $p$ $t$)}
for programs~$p$ (see below)
and postconditions~$t$ (terms of sort \code{Bool},
which state slightly different correctness criteria with respect to termination and nondeterministic choices.

The first one, \code{wp} is Dijkstra's standard weakest precondition that expresses that all executions of~$p$,
when started in the current state, terminate and lead to a state that satisfies~$t$.
For instance, a Hoare triple total correctness $\hoaretotal{\phi}{p}{\psi}$ can be written as the implication \code{(=> $\phi$ (wp $p$ $\psi$))}

Similarly, \code{box} does not require termination (i.e., it expresses the weakest liberal precondition),
i.e., $\hoare{\phi}{p}{\psi}$ can be written as \code{(=> $\phi$ (box $p$ $\psi$))}
The operator \code{dia} reflects angelic execution instead of demonic execution:
For \code{(dia $p$ $t$)} it is required that there is at least one execution of~$p$
that terminates and leads to a state that satisfies~$t$.
The names of the latter two operators is taken from Dynamic Logic~\cite{}.

Moveover, the expression \code{(old $t$)} may be used to refer to initial states of loop executions.

\section{Tool Description}

\section{Examples}

\end{document}
